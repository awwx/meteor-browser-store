// Generated by CoffeeScript 1.4.0
(function() {
  var chrome, itemKey, keysToPoll, localStoragePrefix, polling, polyfilled,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  polyfilled = !(window.localStorage.length != null);

  chrome = $.browser.chrome;

  polling = polyfilled || chrome;

  localStoragePrefix = 'Meteor.BrowserStore.';

  itemKey = function(localStorageKey) {
    if (!_.isString(localStorageKey)) {
      throw new Error('invalid key: ' + localStorageKey);
    }
    if (localStorageKey.substr(0, localStoragePrefix.length) === localStoragePrefix) {
      return localStorageKey.substr(localStoragePrefix.length);
    } else {
      return null;
    }
  };

  
  var stringify = function (value) {
    if (value === undefined)
      return 'undefined';
    return JSON.stringify(value);
  };
  var parse = function (serialized) {
    if (serialized === undefined || serialized === 'undefined')
      return undefined;
    return JSON.parse(serialized);
  };
;


  keysToPoll = [];

  Meteor.BrowserStore = _.extend({}, {
    keys: {},
    keyDeps: {},
    keyValueDeps: {},
    _save: function(key, value) {
      if (value != null) {
        return localStorage.setItem(localStoragePrefix + key, value);
      } else {
        return localStorage.removeItem(localStoragePrefix + key);
      }
    },
    _fetch: function(key) {
      return localStorage.getItem(localStoragePrefix + key);
    },
    _cacheSet: function (key, serializedValue) {
      var self = this;
      var oldSerializedValue = 'undefined';
      if (_.has(self.keys, key)) oldSerializedValue = self.keys[key];
      if (serializedValue === oldSerializedValue)
        return;
      self.keys[key] = serializedValue;

      var invalidateAll = function (cset) {
        cset && cset.invalidateAll();
      };

      invalidateAll(self.keyDeps[key]);
      if (self.keyValueDeps[key]) {
        invalidateAll(self.keyValueDeps[key][oldSerializedValue]);
        invalidateAll(self.keyValueDeps[key][serializedValue]);
      }
    },
    set: function (key, value) {
      var self = this;
      value = stringify(value);
      self._cacheSet(key, value);
      self._save(key, value);
    },
    _initialFetch: function(key) {
      if (polling && __indexOf.call(keysToPoll, key) < 0) {
        keysToPoll.push(key);
        this._refresh(key);
      }
      return void 0;
    },
    get: function(key) {
      this._initialFetch(key);
      this._ensureKey(key);
      this.keyDeps[key].addCurrentContext();
      return parse(this.keys[key]);
    },
    equals: function (key, value) {
      var self = this;
      self._initialFetch(key)
      var context = Meteor.deps.Context.current;

      // We don't allow objects (or arrays that might include objects) for
      // .equals, because JSON.stringify doesn't canonicalize object key
      // order. (We can make equals have the right return value by parsing the
      // current value and using _.isEqual, but we won't have a canonical
      // element of keyValueDeps[key] to store the context.) You can still use
      // "_.isEqual(Session.get(key), value)".
      //
      // XXX we could allow arrays as long as we recursively check that there
      // are no objects
      if (typeof value !== 'string' &&
          typeof value !== 'number' &&
          typeof value !== 'boolean' &&
          typeof value !== 'undefined' &&
          value !== null)
        throw new Error("BrowserStore.equals: value must be scalar");
      var serializedValue = stringify(value);

      if (context) {
        self._ensureKey(key);

        if (! _.has(self.keyValueDeps[key], serializedValue))
          self.keyValueDeps[key][serializedValue] = new Meteor.deps._ContextSet;

        var isNew = self.keyValueDeps[key][serializedValue].add(context);
        if (isNew) {
          context.onInvalidate(function () {
            // clean up [key][serializedValue] if it's now empty, so we don't
            // use O(n) memory for n = values seen ever
            if (self.keyValueDeps[key][serializedValue].isEmpty())
              delete self.keyValueDeps[key][serializedValue];
          });
        }
      }

      var oldValue = undefined;
      if (_.has(self.keys, key)) oldValue = parse(self.keys[key]);
      return oldValue === value;
    },
    _ensureKey: function (key) {
      var self = this;
      if (!(key in self.keyDeps)) {
        self.keyDeps[key] = new Meteor.deps._ContextSet;
        self.keyValueDeps[key] = {};
      }
    },
    _each: function(callback) {
      var i, key, len, localStorageKey, _i, _results;
      if (polyfilled) {
        throw new Error('_each is not supported in the polyfill implementation');
      }
      len = localStorage.length;
      _results = [];
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        localStorageKey = localStorage.key(i);
        key = itemKey(localStorageKey);
        if (key) {
          _results.push(callback(key, localStorage.getItem(localStorageKey)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    _refresh: function(key) {
      return this._cacheSet(key, this._fetch(key));
    },
    _poll: function() {
      var key, _i, _len;
      for (_i = 0, _len = keysToPoll.length; _i < _len; _i++) {
        key = keysToPoll[_i];
        this._refresh(key);
      }
      return void 0;
    },
    _onStorageEvent: function(event) {
      var key;
      if (key = itemKey(event.key)) {
        this._refresh(key);
      }
      return void 0;
    },
    _listenForStorageEvent: function() {
      var _this = this;
      this._each(function(key, val) {
        return _this._cacheSet(key, val);
      });
      if (window.addEventListener) {
        return window.addEventListener('storage', _.bind(this._onStorageEvent, this), false);
      } else if (window.attachEvent) {
        return window.attachEvent('onstorage', _.bind(this._onStorageEvent, this));
      }
    },
    _startup: function() {
      if (polling) {
        return setInterval(_.bind(this._poll, this), 3000);
      } else {
        return this._listenForStorageEvent();
      }
    }
  });

  Meteor.startup(function() {
    return Meteor.BrowserStore._startup();
  });

}).call(this);
